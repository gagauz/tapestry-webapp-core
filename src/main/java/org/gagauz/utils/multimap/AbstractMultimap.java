/*
 * Copyright (C) 2007 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gagauz.utils.multimap;

import java.io.Serializable;
import java.util.*;
import java.util.Map.Entry;

/**
 * Basic implementation of the {@link Multimap} interface. This class represents
 * a multimap as a map that associates each key with a collection of values. All
 * methods of {@link Multimap} are supported, including those specified as
 * optional in the interface.
 * <p/>
 * <p/>
 * To implement a multimap, a subclass must define the method {@link #createCollection()}, which creates an empty collection of values for a key.
 * <p/>
 * <p/>
 * The multimap constructor takes a map that has a single entry for each distinct key. When you insert a key-value pair with a key that isn't already in the
 * multimap, {@code AbstractMultimap} calls {@link #createCollection()} to create the collection of values for that key. The subclass should not call
 * {@link #createCollection()} directly, and a new instance should be created every time the method is called.
 * <p/>
 * <p/>
 * For example, the subclass could pass a {@link java.util.TreeMap} during construction, and {@link #createCollection()} could return a
 * {@link java.util.TreeSet}, in which case the multimap's iterators would propagate through the keys and values in sorted order.
 * <p/>
 * <p/>
 * Keys and values may be null, as long as the underlying collection classes support null elements.
 * <p/>
 * <p/>
 * The collections created by {@link #createCollection()} may or may not allow duplicates. If the collection, such as a {@link Set}, does not support
 * duplicates, an added key-value pair will replace an existing pair with the same key and value, if such a pair is present. With collections like {@link List}
 * that allow duplicates, the collection will keep the existing key-value pairs while adding a new pair.
 * <p/>
 * <p/>
 * This class is not threadsafe when any concurrent operations update the multimap, even if the underlying map and {@link #createCollection()} method return
 * threadsafe classes. Concurrent read operations will work correctly. To allow concurrent update operations, wrap your multimap with a call to
 * {@link Multimaps#synchronizedMultimap}.
 * <p/>
 * <p/>
 * For serialization to work, the subclass must specify explicit {@code readObject} and {@code writeObject} methods.
 *
 * @author Jared Levy
 */
abstract class AbstractMultimap<K, V, C extends Collection<V>> implements Multimap<K, V>, Serializable {
    /*
     * Here's an outline of the overall design.
     * The map variable contains the collection of values associated with each
     * key. When a key-value pair is added to a multimap that didn't previously
     * contain any values for that key, a new collection generated by
     * createCollection is added to the map. That same collection instance
     * remains in the map as long as the multimap has any values for the key. If
     * all values for the key are removed, the key and collection are removed
     * from the map.
     * The get method returns a WrappedCollection, which decorates the collection
     * in the map (if the key is present) or an empty collection (if the key is
     * not present). When the collection delegate in the WrappedCollection is
     * empty, the multimap may contain subsequently added values for that key. To
     * handle that situation, the WrappedCollection checks whether map contains
     * an entry for the provided key, and if so replaces the delegate.
     */

    private static final long serialVersionUID = 2447537837011683357L;

    private static final Iterator<Object> EMPTY_MODIFIABLE_ITERATOR =
            new Iterator<Object>() {
                @Override
                public boolean hasNext() {
                    return false;
                }

                @Override
                public Object next() {
                    throw new NoSuchElementException();
                }

                @Override
                public void remove() {
                    throw new IllegalStateException();
                }
            };

    transient Set<Map.Entry<K, C>> entrySet;

    SortedSet<K> sortedKeySet;

    private transient Map<K, C> map;

    private transient int totalSize;

    private transient Set<K> keySet;

    private transient Collection<V> valuesCollection;

    private transient Collection<Map.Entry<K, V>> entries;

    private transient Map<K, C> asMap;

    /**
     * Creates a new multimap that uses the provided map.
     *
     * @param map place to store the mapping from each key to its corresponding
     *            values
     * @throws IllegalArgumentException if {@code map} is not empty
     */
    protected AbstractMultimap(Map<K, C> map) {
        this.map = map;
    }

    /**
     * Used during deserialization only.
     */
    final void setMap(Map<K, C> map) {
        this.map = map;
        totalSize = 0;
        for (C values : map.values()) {
            totalSize += values.size();
        }
    }

    /**
     * Creates the collection of values for a single key.
     * <p/>
     * <p/>
     * Collections with weak, soft, or phantom references are not supported. Each call to {@code createCollection} should create a new instance.
     * <p/>
     * <p/>
     * The returned collection class determines whether duplicate key-value pairs are allowed.
     *
     * @return an empty collection of values
     */
    abstract C createCollection();

    /**
     * Creates the collection of values for an explicitly provided key. By
     * default, it simply calls {@link #createCollection()}, which is the correct
     * behavior for most implementations. The LinkedHashMultimap class
     * overrides it.
     *
     * @param key key to associate with values in the collection
     * @return an empty collection of values
     */
    C createCollection(K key) {
        return createCollection();
    }

    Map<K, C> backingMap() {
        return map;
    }

    // Query Operations

    @Override
    public int size() {
        return totalSize;
    }

    @Override
    public boolean isEmpty() {
        return totalSize == 0;
    }

    @Override
    public boolean containsKey(Object key) {
        return map.containsKey(key);
    }

    @Override
    public boolean containsValue(Object value) {
        for (C collection : map.values()) {
            if (collection.contains(value)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean containsEntry(Object key, Object value) {
        C collection = map.get(key);
        return collection != null && collection.contains(value);
    }

    // Modification Operations

    @Override
    public boolean put(K key, V value) {
        C collection = getOrCreateCollection(key);

        if (collection.add(value)) {
            totalSize++;
            return true;
        } else {
            return false;
        }
    }

    private C getOrCreateCollection(K key) {
        C collection = map.get(key);
        if (collection == null) {
            collection = createCollection(key);
            map.put(key, collection);
        }
        return collection;
    }

    @Override
    public boolean remove(Object key, Object value) {
        C collection = map.get(key);
        if (collection == null) {
            return false;
        }

        boolean changed = collection.remove(value);
        if (changed) {
            totalSize--;
            if (collection.isEmpty()) {
                map.remove(key);
            }
        }
        return changed;
    }

    // Bulk Operations

    @Override
    public boolean putAll(K key, Iterable<? extends V> values) {
        if (!values.iterator().hasNext()) {
            return false;
        }
        C collection = getOrCreateCollection(key);
        int oldSize = collection.size();

        boolean changed = false;
        if (values instanceof Collection) {
            Collection<? extends V> c = (Collection<? extends V>) values;
            changed = collection.addAll(c);
        } else {
            for (V value : values) {
                changed |= collection.add(value);
            }
        }

        totalSize += (collection.size() - oldSize);
        return changed;
    }

    @Override
    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
        boolean changed = false;
        for (Map.Entry<? extends K, ? extends V> entry : multimap.entries()) {
            changed |= put(entry.getKey(), entry.getValue());
        }
        return changed;
    }

    /**
     * {@inheritDoc}
     * <p/>
     * <p/>
     * The returned collection is immutable.
     */
    @Override
    public C replaceValues(K key, Iterable<? extends V> values) {
        Iterator<? extends V> iterator = values.iterator();
        if (!iterator.hasNext()) {
            return removeAll(key);
        }

        C collection = getOrCreateCollection(key);
        C oldValues = createCollection();
        oldValues.addAll(collection);

        totalSize -= collection.size();
        collection.clear();

        while (iterator.hasNext()) {
            if (collection.add(iterator.next())) {
                totalSize++;
            }
        }

        return unmodifiableCollectionSubclass(oldValues);
    }

    /**
     * {@inheritDoc}
     * <p/>
     * <p/>
     * The returned collection is immutable.
     */
    @Override
    public C removeAll(Object key) {
        C collection = map.remove(key);
        C output = createCollection();

        if (collection != null) {
            output.addAll(collection);
            totalSize -= collection.size();
            collection.clear();
        }

        return unmodifiableCollectionSubclass(output);
    }

    @SuppressWarnings("unchecked")
    private C unmodifiableCollectionSubclass(C collection) {
        if (collection instanceof SortedSet) {
            return (C) Collections.unmodifiableSortedSet((SortedSet<V>) collection);
        } else if (collection instanceof Set) {
            return (C) Collections.unmodifiableSet((Set<V>) collection);
        } else if (collection instanceof List) {
            return (C) Collections.unmodifiableList((List<V>) collection);
        } else {
            return (C) Collections.unmodifiableCollection(collection);
        }
    }

    @Override
    public void clear() {
        // Clear each collection, to make previously returned collections empty.
        for (C collection : map.values()) {
            collection.clear();
        }
        map.clear();
        totalSize = 0;
    }

    // Views

    /**
     * {@inheritDoc}
     * <p/>
     * <p/>
     * The returned collection is not serializable.
     */
    @Override
    public C get(K key) {
        C collection = map.get(key);
        if (collection == null) {
            collection = createCollection(key);
        }
        return wrapCollection(key, collection);
    }

    /**
     * {@inheritDoc}
     * <p/>
     * <p/>
     * The returned collection is not serializable.
     */
    @Override
    public V getFirst(K key) {
        C collection = map.get(key);
        if (collection != null) {
            for (V v : collection) {
                return v;
            }
        }
        return null;
    }

    /**
     * Generates a decorated collection that remains consistent with the values in
     * the multimap for the provided key. Changes to the multimap may alter the
     * returned collection, and vice versa.
     */
    @SuppressWarnings("unchecked")
    private C wrapCollection(
                             K key, C collection) {
        if (collection instanceof SortedSet) {
            return (C) new WrappedSortedSet(key, (SortedSet<V>) collection, null);
        } else if (collection instanceof Set) {
            return (C) new WrappedSet(key, (Set<V>) collection);
        } else if (collection instanceof List) {
            return (C) wrapList(key, (List<V>) collection, null);
        } else {
            return (C) new WrappedCollection(key, collection, null);
        }
    }

    private List<V> wrapList(
                             K key, List<V> list, WrappedCollection ancestor) {
        return (list instanceof RandomAccess)
                ? new RandomAccessWrappedList(key, list, ancestor)
                : new WrappedList(key, list, ancestor);
    }

    /**
     * Collection decorator that stays in sync with the multimap values for a key.
     * There are two kinds of wrapped collections: full and subcollections. Both
     * have a delegate pointing to the underlying collection class.
     * <p/>
     * <p/>
     * Full collections, identified by a null ancestor field, contain all multimap values for a given key. Its delegate is a value in
     * {@link AbstractMultimap#map} whenever the delegate is non-empty. The {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods ensure
     * that the {@code WrappedCollection} and map remain consistent.
     * <p/>
     * <p/>
     * A subcollection, such as a sublist, contains some of the values for a given key. Its ancestor field points to the full wrapped collection with all values
     * for the key. The subcollection {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods call the corresponding methods of the full
     * wrapped collection.
     */
    private class WrappedCollection extends AbstractCollection<V> {
        final K key;
        C delegate;
        final WrappedCollection ancestor;
        final C ancestorDelegate;

        WrappedCollection(K key, C delegate,
                WrappedCollection ancestor) {
            this.key = key;
            this.delegate = delegate;
            this.ancestor = ancestor;
            this.ancestorDelegate = (ancestor == null) ? null : ancestor.getDelegate();
        }

        /**
         * If the delegate collection is empty, but the multimap has values for the
         * key, replace the delegate with the new collection for the key.
         * <p/>
         * <p/>
         * For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't changed.
         */
        void refreshIfEmpty() {
            if (ancestor != null) {
                ancestor.refreshIfEmpty();
                if (ancestor.getDelegate() != ancestorDelegate) {
                    throw new ConcurrentModificationException();
                }
            } else if (delegate.isEmpty()) {
                C newDelegate = map.get(key);
                if (newDelegate != null) {
                    delegate = newDelegate;
                }
            }
        }

        /**
         * If collection is empty, remove it from {@code map}. For subcollections,
         * check whether the ancestor collection is empty.
         */
        void removeIfEmpty() {
            if (ancestor != null) {
                ancestor.removeIfEmpty();
            } else if (delegate.isEmpty()) {
                map.remove(key);
            }
        }

        K getKey() {
            return key;
        }

        /**
         * Add the delegate to the map. Other {@code WrappedCollection} methods
         * should call this method after adding elements to a previously empty
         * collection.
         * <p/>
         * <p/>
         * Subcollection add the ancestor's delegate instead.
         */
        void addToMap() {
            if (ancestor != null) {
                ancestor.addToMap();
            } else {
                map.put(key, delegate);
            }
        }

        @Override
        public int size() {
            refreshIfEmpty();
            return delegate.size();
        }

        @Override
        public boolean equals(Object object) {
            if (object == this) {
                return true;
            }
            refreshIfEmpty();
            return delegate.equals(object);
        }

        @Override
        public int hashCode() {
            refreshIfEmpty();
            return delegate.hashCode();
        }

        @Override
        public String toString() {
            refreshIfEmpty();
            return delegate.toString();
        }

        C getDelegate() {
            return delegate;
        }

        @Override
        public Iterator<V> iterator() {
            refreshIfEmpty();
            return new WrappedIterator();
        }

        /**
         * Collection iterator for {@code WrappedCollection}.
         */
        class WrappedIterator implements Iterator<V> {
            final Iterator<V> delegateIterator;
            final C originalDelegate = delegate;

            WrappedIterator() {
                delegateIterator = iteratorOrListIterator(delegate);
            }

            WrappedIterator(Iterator<V> delegateIterator) {
                this.delegateIterator = delegateIterator;
            }

            /**
             * If the delegate changed since the iterator was created, the iterator is
             * no longer valid.
             */
            void validateIterator() {
                refreshIfEmpty();
                if (delegate != originalDelegate) {
                    throw new ConcurrentModificationException();
                }
            }

            @Override
            public boolean hasNext() {
                validateIterator();
                return delegateIterator.hasNext();
            }

            @Override
            public V next() {
                validateIterator();
                return delegateIterator.next();
            }

            @Override
            public void remove() {
                delegateIterator.remove();
                totalSize--;
                removeIfEmpty();
            }

            Iterator<V> getDelegateIterator() {
                validateIterator();
                return delegateIterator;
            }
        }

        @Override
        public boolean add(V value) {
            refreshIfEmpty();
            boolean wasEmpty = delegate.isEmpty();
            boolean changed = delegate.add(value);
            if (changed) {
                totalSize++;
                if (wasEmpty) {
                    addToMap();
                }
            }
            return changed;
        }

        WrappedCollection getAncestor() {
            return ancestor;
        }

        // The following methods are provided for better performance.

        @Override
        public boolean addAll(Collection<? extends V> collection) {
            if (collection.isEmpty()) {
                return false;
            }
            int oldSize = size(); // calls refreshIfEmpty
            boolean changed = delegate.addAll(collection);
            if (changed) {
                int newSize = delegate.size();
                totalSize += (newSize - oldSize);
                if (oldSize == 0) {
                    addToMap();
                }
            }
            return changed;
        }

        @Override
        public boolean contains(Object o) {
            refreshIfEmpty();
            return delegate.contains(o);
        }

        @Override
        public boolean containsAll(Collection<?> c) {
            refreshIfEmpty();
            return delegate.containsAll(c);
        }

        @Override
        public void clear() {
            int oldSize = size(); // calls refreshIfEmpty
            if (oldSize == 0) {
                return;
            }
            delegate.clear();
            totalSize -= oldSize;
            removeIfEmpty(); // maybe shouldn't be removed if this is a sublist
        }

        @Override
        public boolean remove(Object o) {
            refreshIfEmpty();
            boolean changed = delegate.remove(o);
            if (changed) {
                totalSize--;
                removeIfEmpty();
            }
            return changed;
        }

        @Override
        public boolean removeAll(Collection<?> c) {
            if (c.isEmpty()) {
                return false;
            }
            int oldSize = size(); // calls refreshIfEmpty
            boolean changed = delegate.removeAll(c);
            if (changed) {
                int newSize = delegate.size();
                totalSize += (newSize - oldSize);
                removeIfEmpty();
            }
            return changed;
        }

        @Override
        public boolean retainAll(Collection<?> c) {
            int oldSize = size(); // calls refreshIfEmpty
            boolean changed = delegate.retainAll(c);
            if (changed) {
                int newSize = delegate.size();
                totalSize += (newSize - oldSize);
                removeIfEmpty();
            }
            return changed;
        }
    }

    private Iterator<V> iteratorOrListIterator(C collection) {
        return (collection instanceof List)
                ? ((List<V>) collection).listIterator()
                : collection.iterator();
    }

    /**
     * Set decorator that stays in sync with the multimap values for a key.
     */
    private class WrappedSet extends WrappedCollection implements Set<V> {
        @SuppressWarnings("unchecked")
        WrappedSet(K key, Set<V> delegate) {
            super(key, (C) delegate, null);
        }
    }

    /**
     * SortedSet decorator that stays in sync with the multimap values for a key.
     */
    private class WrappedSortedSet extends WrappedCollection
            implements SortedSet<V> {
        @SuppressWarnings("unchecked")
        WrappedSortedSet(K key, SortedSet<V> delegate,
                WrappedCollection ancestor) {
            super(key, (C) delegate, ancestor);
        }

        SortedSet<V> getSortedSetDelegate() {
            return (SortedSet<V>) getDelegate();
        }

        @Override
        public Comparator<? super V> comparator() {
            return getSortedSetDelegate().comparator();
        }

        @Override
        public V first() {
            refreshIfEmpty();
            return getSortedSetDelegate().first();
        }

        @Override
        public V last() {
            refreshIfEmpty();
            return getSortedSetDelegate().last();
        }

        @Override
        public SortedSet<V> headSet(V toElement) {
            refreshIfEmpty();
            return new WrappedSortedSet(
                    getKey(), getSortedSetDelegate().headSet(toElement),
                    (getAncestor() == null) ? this : getAncestor());
        }

        @Override
        public SortedSet<V> subSet(V fromElement, V toElement) {
            refreshIfEmpty();
            return new WrappedSortedSet(
                    getKey(), getSortedSetDelegate().subSet(fromElement, toElement),
                    (getAncestor() == null) ? this : getAncestor());
        }

        @Override
        public SortedSet<V> tailSet(V fromElement) {
            refreshIfEmpty();
            return new WrappedSortedSet(
                    getKey(), getSortedSetDelegate().tailSet(fromElement),
                    (getAncestor() == null) ? this : getAncestor());
        }
    }

    /**
     * List decorator that stays in sync with the multimap values for a key.
     */
    private class WrappedList extends WrappedCollection implements List<V> {
        @SuppressWarnings("unchecked")
        WrappedList(K key, List<V> delegate, WrappedCollection ancestor) {
            super(key, (C) delegate, ancestor);
        }

        List<V> getListDelegate() {
            return (List<V>) getDelegate();
        }

        @Override
        public boolean addAll(int index, Collection<? extends V> c) {
            if (c.isEmpty()) {
                return false;
            }
            int oldSize = size(); // calls refreshIfEmpty
            boolean changed = getListDelegate().addAll(index, c);
            if (changed) {
                int newSize = getDelegate().size();
                totalSize += (newSize - oldSize);
                if (oldSize == 0) {
                    addToMap();
                }
            }
            return changed;
        }

        @Override
        public V get(int index) {
            refreshIfEmpty();
            return getListDelegate().get(index);
        }

        @Override
        public V set(int index, V element) {
            refreshIfEmpty();
            return getListDelegate().set(index, element);
        }

        @Override
        public void add(int index, V element) {
            refreshIfEmpty();
            boolean wasEmpty = getDelegate().isEmpty();
            getListDelegate().add(index, element);
            totalSize++;
            if (wasEmpty) {
                addToMap();
            }
        }

        @Override
        public V remove(int index) {
            refreshIfEmpty();
            V value = getListDelegate().remove(index);
            totalSize--;
            removeIfEmpty();
            return value;
        }

        @Override
        public int indexOf(Object o) {
            refreshIfEmpty();
            return getListDelegate().indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            refreshIfEmpty();
            return getListDelegate().lastIndexOf(o);
        }

        @Override
        public ListIterator<V> listIterator() {
            refreshIfEmpty();
            return new WrappedListIterator();
        }

        @Override
        public ListIterator<V> listIterator(int index) {
            refreshIfEmpty();
            return new WrappedListIterator(index);
        }

        @Override
        public List<V> subList(int fromIndex, int toIndex) {
            refreshIfEmpty();
            return wrapList(getKey(),
                    getListDelegate().subList(fromIndex, toIndex),
                    (getAncestor() == null) ? this : getAncestor());
        }

        /**
         * ListIterator decorator.
         */
        private class WrappedListIterator extends WrappedIterator
                implements ListIterator<V> {
            WrappedListIterator() {
            }

            public WrappedListIterator(int index) {
                super(getListDelegate().listIterator(index));
            }

            private ListIterator<V> getDelegateListIterator() {
                return (ListIterator<V>) getDelegateIterator();
            }

            @Override
            public boolean hasPrevious() {
                return getDelegateListIterator().hasPrevious();
            }

            @Override
            public V previous() {
                return getDelegateListIterator().previous();
            }

            @Override
            public int nextIndex() {
                return getDelegateListIterator().nextIndex();
            }

            @Override
            public int previousIndex() {
                return getDelegateListIterator().previousIndex();
            }

            @Override
            public void set(V value) {
                getDelegateListIterator().set(value);
            }

            @Override
            public void add(V value) {
                boolean wasEmpty = isEmpty();
                getDelegateListIterator().add(value);
                totalSize++;
                if (wasEmpty) {
                    addToMap();
                }
            }
        }
    }

    /**
     * List decorator that stays in sync with the multimap values for a key and
     * supports rapid random access.
     */
    private class RandomAccessWrappedList extends WrappedList
            implements RandomAccess {
        RandomAccessWrappedList(K key, List<V> delegate,
                WrappedCollection ancestor) {
            super(key, delegate, ancestor);
        }
    }

    @Override
    public Set<K> keySet() {
        Set<K> result = keySet;
        return (result == null) ? keySet = createKeySet() : result;
    }

    private Set<K> createKeySet() {
        return (map instanceof SortedMap)
                ? new SortedKeySet((SortedMap<K, C>) map) : new KeySet(map);
    }

    private class KeySet extends AbstractSet<K> {

        /**
         * This is usually the same as map, except when someone requests a
         * subcollection of a {@link SortedKeySet}.
         */
        final Map<K, C> subMap;

        KeySet(final Map<K, C> subMap) {
            this.subMap = subMap;
        }

        @Override
        public int size() {
            return subMap.size();
        }

        @Override
        public Iterator<K> iterator() {
            return new Iterator<K>() {
                final Iterator<Map.Entry<K, C>> entryIterator = subMap.entrySet().iterator();
                Map.Entry<K, C> entry;

                @Override
                public boolean hasNext() {
                    return entryIterator.hasNext();
                }

                @Override
                public K next() {
                    entry = entryIterator.next();
                    return entry.getKey();
                }

                @Override
                public void remove() {
                    C collection = entry.getValue();
                    entryIterator.remove();
                    totalSize -= collection.size();
                    collection.clear();
                }
            };
        }

        // The following methods are included for better performance.

        @Override
        public boolean contains(Object key) {
            return subMap.containsKey(key);
        }

        @Override
        public boolean remove(Object key) {
            int count = 0;
            C collection = subMap.remove(key);
            if (collection != null) {
                count = collection.size();
                collection.clear();
                totalSize -= count;
            }
            return count > 0;
        }

        @Override
        public boolean containsAll(Collection<?> c) {
            return subMap.keySet().containsAll(c);
        }

        @Override
        public boolean equals(Object object) {
            return this == object || this.subMap.keySet().equals(object);
        }

        @Override
        public int hashCode() {
            return subMap.keySet().hashCode();
        }
    }

    private class SortedKeySet extends KeySet implements SortedSet<K> {

        SortedKeySet(SortedMap<K, C> subMap) {
            super(subMap);
        }

        SortedMap<K, C> sortedMap() {
            return (SortedMap<K, C>) subMap;
        }

        @Override
        public Comparator<? super K> comparator() {
            return sortedMap().comparator();
        }

        @Override
        public K first() {
            return sortedMap().firstKey();
        }

        @Override
        public SortedSet<K> headSet(K toElement) {
            return new SortedKeySet(sortedMap().headMap(toElement));
        }

        @Override
        public K last() {
            return sortedMap().lastKey();
        }

        @Override
        public SortedSet<K> subSet(K fromElement, K toElement) {
            return new SortedKeySet(sortedMap().subMap(fromElement, toElement));
        }

        @Override
        public SortedSet<K> tailSet(K fromElement) {
            return new SortedKeySet(sortedMap().tailMap(fromElement));
        }
    }

    /**
     * Removes all values for the provided key. Unlike {@link #removeAll}, it
     * returns the number of removed mappings.
     */
    private int removeValuesForKey(Object key) {
        C collection;
        try {
            collection = map.remove(key);
        } catch (NullPointerException e) {
            return 0;
        } catch (ClassCastException e) {
            return 0;
        }

        int count = 0;
        if (collection != null) {
            count = collection.size();
            collection.clear();
            totalSize -= count;
        }
        return count;
    }

    /**
     * {@inheritDoc}
     * <p/>
     * <p/>
     * The iterator generated by the returned collection traverses the values for one key, followed by the values of a second key, and so on.
     */
    @Override
    public Collection<V> values() {
        Collection<V> result = valuesCollection;
        return (result == null) ? valuesCollection = new Values() : result;
    }

    private class Values extends AbstractCollection<V> {
        @Override
        public Iterator<V> iterator() {
            return new ValueIterator();
        }

        @Override
        public int size() {
            return totalSize;
        }

        // The following methods are included to improve performance.

        @Override
        public void clear() {
            AbstractMultimap.this.clear();
        }

        @Override
        public boolean contains(Object value) {
            return containsValue(value);
        }
    }

    /**
     * Iterator across all values.
     */
    private class ValueIterator implements Iterator<V> {
        final Iterator<Map.Entry<K, V>> entryIterator = createEntryIterator();

        @Override
        public boolean hasNext() {
            return entryIterator.hasNext();
        }

        @Override
        public V next() {
            return entryIterator.next().getValue();
        }

        @Override
        public void remove() {
            entryIterator.remove();
        }
    }

    // TODO: should we copy this javadoc to each concrete class, so that classes
    // like LinkedHashMultimap that need to say something different are still
    // able to {@inheritDoc} all the way from Multimap?

    /**
     * {@inheritDoc}
     * <p/>
     * <p/>
     * The iterator generated by the returned collection traverses the values for one key, followed by the values of a second key, and so on.
     * <p/>
     * <p/>
     * Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the time the entry is returned by a method call to the collection or
     * its iterator.
     */
    @Override
    public Collection<Map.Entry<K, V>> entries() {
        Collection<Map.Entry<K, V>> result = entries;
        return (entries == null) ? entries = createEntries() : result;
    }

    private Collection<Map.Entry<K, V>> createEntries() {
        // TODO: can we refactor so we're not doing "this instanceof"?
        return new Entries();
        // return (this instanceof SetMultimap) ? new EntrySet() : new Entries();
    }

    /**
     * Entries for multimap.
     */
    private class Entries extends AbstractCollection<Map.Entry<K, V>> {
        @Override
        public Iterator<Map.Entry<K, V>> iterator() {
            return createEntryIterator();
        }

        @Override
        public int size() {
            return totalSize;
        }

        // The following methods are included to improve performance.

        @Override
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
            }
            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
            return containsEntry(entry.getKey(), entry.getValue());
        }

        @Override
        public void clear() {
            AbstractMultimap.this.clear();
        }

        @Override
        public boolean remove(Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
            }
            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
            return AbstractMultimap.this.remove(entry.getKey(), entry.getValue());
        }
    }

    /**
     * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and {@code values().iterator()}. The default
     * behavior, which traverses the values for one key, the values for a second
     * key, and so on, suffices for most {@code AbstractMultimap} implementations.
     *
     * @return an iterator across map entries
     */
    Iterator<Map.Entry<K, V>> createEntryIterator() {
        return new EntryIterator();
    }

    /**
     * Iterator across all key-value pairs.
     */
    private class EntryIterator implements Iterator<Map.Entry<K, V>> {
        final Iterator<Map.Entry<K, C>> keyIterator;
        K key;
        C collection;
        Iterator<V> valueIterator;

        EntryIterator() {
            keyIterator = map.entrySet().iterator();
            if (keyIterator.hasNext()) {
                findValueIteratorAndKey();
            } else {
                valueIterator = emptyModifiableIterator();
            }
        }

        void findValueIteratorAndKey() {
            Map.Entry<K, C> entry = keyIterator.next();
            key = entry.getKey();
            collection = entry.getValue();
            valueIterator = collection.iterator();
        }

        @Override
        public boolean hasNext() {
            return keyIterator.hasNext() || valueIterator.hasNext();
        }

        @Override
        public Map.Entry<K, V> next() {
            if (!valueIterator.hasNext()) {
                findValueIteratorAndKey();
            }
            return immutableEntry(key, valueIterator.next());
        }

        @Override
        public void remove() {
            valueIterator.remove();
            if (collection.isEmpty()) {
                keyIterator.remove();
            }
            totalSize--;
        }
    }

    // Casting to any type is safe since there are no actual elements.
    @SuppressWarnings("unchecked")
    private static <T> Iterator<T> emptyModifiableIterator() {
        return (Iterator<T>) EMPTY_MODIFIABLE_ITERATOR;
    }

    static boolean setEquals(Set<?> thisSet, Object object) {
        if (object == thisSet) {
            return true;
        }
        if (object instanceof Set) {
            Set<?> thatSet = (Set<?>) object;
            return thisSet.size() == thatSet.size()
                    && thisSet.containsAll(thatSet);
        }
        return false;
    }

    static int hashCodeImpl(Set<?> s) {
        int hashCode = 0;
        for (Object o : s) {
            hashCode += o != null ? o.hashCode() : 0;
        }
        return hashCode;
    }

    protected Map<K, C> createMap() {
        if (null == asMap) {
            asMap = (map instanceof SortedMap)
                    ? new SortedAsMap((SortedMap<K, C>) map) : new AsMap(map);
        }
        return asMap;
    }

    private class AsMap extends AbstractMap<K, C> {
        /**
         * Usually the same as map, but smaller for the headMap(), tailMap(), or
         * subMap() of a SortedAsMap.
         */
        final transient Map<K, C> submap;

        AsMap(Map<K, C> submap) {
            this.submap = submap;
        }

        @Override
        public Set<Map.Entry<K, C>> entrySet() {
            Set<Map.Entry<K, C>> result = entrySet;
            return (entrySet == null) ? entrySet = new AsMapEntries() : result;
        }

        // The following methods are included for performance.

        @Override
        public boolean containsKey(Object key) {
            return submap.containsKey(key);
        }

        @Override
        public C get(Object key) {
            C collection = submap.get(key);
            if (collection == null) {
                return null;
            }
            @SuppressWarnings("unchecked")
            K k = (K) key;
            return wrapCollection(k, collection);
        }

        @Override
        public Set<K> keySet() {
            return AbstractMultimap.this.keySet();
        }

        @Override
        public C remove(Object key) {
            C collection = submap.remove(key);
            if (collection == null) {
                return null;
            }

            C output = createCollection();
            output.addAll(collection);
            totalSize -= collection.size();
            collection.clear();
            return output;
        }

        @Override
        public boolean equals(Object object) {
            return this == object || submap.equals(object);
        }

        @Override
        public int hashCode() {
            return submap.hashCode();
        }

        @Override
        public String toString() {
            return submap.toString();
        }

        class AsMapEntries extends AbstractSet<Map.Entry<K, C>> {
            @Override
            public Iterator<Map.Entry<K, C>> iterator() {
                return new AsMapIterator();
            }

            @Override
            public int size() {
                return submap.size();
            }

            // The following methods are included for performance.

            @Override
            public boolean contains(Object o) {
                return submap.entrySet().contains(o);
            }

            @Override
            public boolean remove(Object o) {
                if (!contains(o)) {
                    return false;
                }
                Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                removeValuesForKey(entry.getKey());
                return true;
            }
        }

        /**
         * Iterator across all keys and value collections.
         */
        class AsMapIterator implements Iterator<Map.Entry<K, C>> {
            final Iterator<Map.Entry<K, C>> delegateIterator = submap.entrySet().iterator();
            C collection;

            @Override
            public boolean hasNext() {
                return delegateIterator.hasNext();
            }

            @Override
            public Map.Entry<K, C> next() {
                Map.Entry<K, C> entry = delegateIterator.next();
                K key = entry.getKey();
                collection = entry.getValue();
                return immutableEntry(key, wrapCollection(key, collection));
            }

            @Override
            public void remove() {
                delegateIterator.remove();
                totalSize -= collection.size();
                collection.clear();
            }
        }
    }

    private class SortedAsMap extends AsMap
            implements SortedMap<K, C> {
        SortedAsMap(SortedMap<K, C> submap) {
            super(submap);
        }

        SortedMap<K, C> sortedMap() {
            return (SortedMap<K, C>) submap;
        }

        @Override
        public Comparator<? super K> comparator() {
            return sortedMap().comparator();
        }

        @Override
        public K firstKey() {
            return sortedMap().firstKey();
        }

        @Override
        public K lastKey() {
            return sortedMap().lastKey();
        }

        @Override
        public SortedMap<K, C> headMap(K toKey) {
            return new SortedAsMap(sortedMap().headMap(toKey));
        }

        @Override
        public SortedMap<K, C> subMap(K fromKey, K toKey) {
            return new SortedAsMap(sortedMap().subMap(fromKey, toKey));
        }

        @Override
        public SortedMap<K, C> tailMap(K fromKey) {
            return new SortedAsMap(sortedMap().tailMap(fromKey));
        }

        // returns a SortedSet, even though returning a Set would be sufficient to
        // satisfy the SortedMap.keySet() interface
        @Override
        public SortedSet<K> keySet() {
            SortedSet<K> result = sortedKeySet;
            return (result == null)
                    ? sortedKeySet = new SortedKeySet(sortedMap()) : result;
        }
    }

    // Comparison and hashing

    @Override
    public boolean equals(Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof Multimap) {
            Multimap<?, ?> that = (Multimap<?, ?>) object;
            return this.map.equals(that.asMap());
        }
        return false;
    }

    /**
     * Returns the hash code for this multimap.
     * <p/>
     * <p/>
     * The hash code of a multimap is defined as the hash code of the map view, as returned by {@link Multimap#asMap}.
     *
     * @see Map#hashCode
     */
    @Override
    public int hashCode() {
        return map.hashCode();
    }

    /**
     * Returns a string representation of the multimap, generated by calling {@code toString} on the map returned by {@link Multimap#asMap}.
     *
     * @return a string representation of the multimap
     */
    @Override
    public String toString() {
        return map.toString();
    }

    public static <K, V> Entry<K, V> immutableEntry(
                                                    K key, V value) {
        return new ImmutableEntry<K, V>(key, value);
    }

    static class ImmutableEntry<K, V> extends AbstractMapEntry<K, V> implements
            Serializable {

        private static final long serialVersionUID = 0;

        private final K key;
        private final V value;

        ImmutableEntry(K key, V value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public K getKey() {
            return key;
        }

        @Override
        public V getValue() {
            return value;
        }
    }

    abstract static class AbstractMapEntry<K, V> implements Entry<K, V> {

        @Override
        public abstract K getKey();

        @Override
        public abstract V getValue();

        @Override
        public V setValue(V value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean equals(Object object) {
            if (object instanceof Entry) {
                Entry<?, ?> that = (Entry<?, ?>) object;
                return equal(this.getKey(), that.getKey())
                        && equal(this.getValue(), that.getValue());
            }
            return false;
        }

        @Override
        public int hashCode() {
            K k = getKey();
            V v = getValue();
            return ((k == null) ? 0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());
        }

        /**
         * Returns a string representation of the form <code>{key}={value}</code>.
         */
        @Override
        public String toString() {
            return getKey() + "=" + getValue();
        }
    }

    public static boolean equal(Object a, Object b) {
        return a == b || (a != null && a.equals(b));
    }
}
